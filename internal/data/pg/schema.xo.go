// Package pg contains generated code for schema 'public'.
package pg

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"

	"gitlab.com/distributed_lab/kit/pgdb"
	"gitlab.com/distributed_lab/logan/v3/errors"
	"github.com/rarimo/horizon-svc/internal/data"
)

// Storage is the helper struct for database operations
type Storage struct {
	db *pgdb.DB
}

// New - returns new instance of storage
func New(db *pgdb.DB) *Storage {
	return &Storage{
		db,
	}
}

// DB - returns db used by Storage
func (s *Storage) DB() *pgdb.DB {
	return s.db
}

// Clone - returns new storage with clone of db
func (s *Storage) Clone() data.Storage {
	return New(s.db.Clone())
}

// Transaction begins a transaction on repo.
func (s *Storage) Transaction(tx func() error) error {
	return s.db.Transaction(tx)
} // ApprovalQ represents helper struct to access row of 'approvals'.
type ApprovalQ struct {
	db *pgdb.DB
}

// NewApprovalQ  - creates new instance
func NewApprovalQ(db *pgdb.DB) ApprovalQ {
	return ApprovalQ{
		db,
	}
}

// ApprovalQ  - creates new instance of ApprovalQ
func (s Storage) ApprovalQ() data.ApprovalQ {
	return NewApprovalQ(s.DB())
}

var colsApproval = `id, transfer_index, rarimo_transaction, created_at`

// InsertCtx inserts a Approval to the database.
func (q ApprovalQ) InsertCtx(ctx context.Context, a *data.Approval) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.approvals (` +
		`transfer_index, rarimo_transaction, created_at` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) RETURNING id`
		// run

	err := q.db.GetRawContext(ctx, &a.ID, sqlstr, a.TransferIndex, a.RarimoTransaction, a.CreatedAt)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// Insert insert a Approval to the database.
func (q ApprovalQ) Insert(a *data.Approval) error {
	return q.InsertCtx(context.Background(), a)
}

// UpdateCtx updates a Approval in the database.
func (q ApprovalQ) UpdateCtx(ctx context.Context, a *data.Approval) error {
	// update with composite primary key
	sqlstr := `UPDATE public.approvals SET ` +
		`transfer_index = $1, rarimo_transaction = $2 ` +
		`WHERE id = $3`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, a.TransferIndex, a.RarimoTransaction, a.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Approval in the database.
func (q ApprovalQ) Update(a *data.Approval) error {
	return q.UpdateCtx(context.Background(), a)
}

// UpsertCtx performs an upsert for Approval.
func (q ApprovalQ) UpsertCtx(ctx context.Context, a *data.Approval) error {
	// upsert
	sqlstr := `INSERT INTO public.approvals (` +
		`id, transfer_index, rarimo_transaction, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`transfer_index = EXCLUDED.transfer_index, rarimo_transaction = EXCLUDED.rarimo_transaction `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, a.ID, a.TransferIndex, a.RarimoTransaction, a.CreatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Approval.
func (q ApprovalQ) Upsert(a *data.Approval) error {
	return q.UpsertCtx(context.Background(), a)
}

// DeleteCtx deletes the Approval from the database.
func (q ApprovalQ) DeleteCtx(ctx context.Context, a *data.Approval) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.approvals ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, a.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Approval from the database.
func (q ApprovalQ) Delete(a *data.Approval) error {
	return q.DeleteCtx(context.Background(), a)
} // CollectionQ represents helper struct to access row of 'collections'.
type CollectionQ struct {
	db *pgdb.DB
}

// NewCollectionQ  - creates new instance
func NewCollectionQ(db *pgdb.DB) CollectionQ {
	return CollectionQ{
		db,
	}
}

// CollectionQ  - creates new instance of CollectionQ
func (s Storage) CollectionQ() data.CollectionQ {
	return NewCollectionQ(s.DB())
}

var colsCollection = `id, index, metadata, created_at, updated_at`

// InsertCtx inserts a Collection to the database.
func (q CollectionQ) InsertCtx(ctx context.Context, c *data.Collection) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.collections (` +
		`index, metadata, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) RETURNING id`
		// run

	err := q.db.GetRawContext(ctx, &c.ID, sqlstr, c.Index, c.Metadata, c.CreatedAt, c.UpdatedAt)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// Insert insert a Collection to the database.
func (q CollectionQ) Insert(c *data.Collection) error {
	return q.InsertCtx(context.Background(), c)
}

// UpdateCtx updates a Collection in the database.
func (q CollectionQ) UpdateCtx(ctx context.Context, c *data.Collection) error {
	// update with composite primary key
	sqlstr := `UPDATE public.collections SET ` +
		`index = $1, metadata = $2, updated_at = $3 ` +
		`WHERE id = $4`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, c.Index, c.Metadata, c.UpdatedAt, c.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Collection in the database.
func (q CollectionQ) Update(c *data.Collection) error {
	return q.UpdateCtx(context.Background(), c)
}

// UpsertCtx performs an upsert for Collection.
func (q CollectionQ) UpsertCtx(ctx context.Context, c *data.Collection) error {
	// upsert
	sqlstr := `INSERT INTO public.collections (` +
		`id, index, metadata, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`index = EXCLUDED.index, metadata = EXCLUDED.metadata, updated_at = EXCLUDED.updated_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, c.ID, c.Index, c.Metadata, c.CreatedAt, c.UpdatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Collection.
func (q CollectionQ) Upsert(c *data.Collection) error {
	return q.UpsertCtx(context.Background(), c)
}

// DeleteCtx deletes the Collection from the database.
func (q CollectionQ) DeleteCtx(ctx context.Context, c *data.Collection) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.collections ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, c.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Collection from the database.
func (q CollectionQ) Delete(c *data.Collection) error {
	return q.DeleteCtx(context.Background(), c)
} // CollectionChainMappingQ represents helper struct to access row of 'collection_chain_mappings'.
type CollectionChainMappingQ struct {
	db *pgdb.DB
}

// NewCollectionChainMappingQ  - creates new instance
func NewCollectionChainMappingQ(db *pgdb.DB) CollectionChainMappingQ {
	return CollectionChainMappingQ{
		db,
	}
}

// CollectionChainMappingQ  - creates new instance of CollectionChainMappingQ
func (s Storage) CollectionChainMappingQ() data.CollectionChainMappingQ {
	return NewCollectionChainMappingQ(s.DB())
}

var colsCollectionChainMapping = `collection, network, address, token_type, wrapped, decimals, created_at, updated_at`

// InsertCtx inserts a CollectionChainMapping to the database.
func (q CollectionChainMappingQ) InsertCtx(ctx context.Context, ccm *data.CollectionChainMapping) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.collection_chain_mappings (` +
		`collection, network, address, token_type, wrapped, decimals, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, ccm.Collection, ccm.Network, ccm.Address, ccm.TokenType, ccm.Wrapped, ccm.Decimals, ccm.CreatedAt, ccm.UpdatedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a CollectionChainMapping to the database.
func (q CollectionChainMappingQ) Insert(ccm *data.CollectionChainMapping) error {
	return q.InsertCtx(context.Background(), ccm)
}

// UpdateCtx updates a CollectionChainMapping in the database.
func (q CollectionChainMappingQ) UpdateCtx(ctx context.Context, ccm *data.CollectionChainMapping) error {
	// update with composite primary key
	sqlstr := `UPDATE public.collection_chain_mappings SET ` +
		`address = $1, token_type = $2, wrapped = $3, decimals = $4, updated_at = $5 ` +
		`WHERE collection = $6 AND network = $7`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, ccm.Address, ccm.TokenType, ccm.Wrapped, ccm.Decimals, ccm.UpdatedAt, ccm.Collection, ccm.Network)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a CollectionChainMapping in the database.
func (q CollectionChainMappingQ) Update(ccm *data.CollectionChainMapping) error {
	return q.UpdateCtx(context.Background(), ccm)
}

// UpsertCtx performs an upsert for CollectionChainMapping.
func (q CollectionChainMappingQ) UpsertCtx(ctx context.Context, ccm *data.CollectionChainMapping) error {
	// upsert
	sqlstr := `INSERT INTO public.collection_chain_mappings (` +
		`collection, network, address, token_type, wrapped, decimals, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)` +
		` ON CONFLICT (collection, network) DO ` +
		`UPDATE SET ` +
		`address = EXCLUDED.address, token_type = EXCLUDED.token_type, wrapped = EXCLUDED.wrapped, decimals = EXCLUDED.decimals, updated_at = EXCLUDED.updated_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, ccm.Collection, ccm.Network, ccm.Address, ccm.TokenType, ccm.Wrapped, ccm.Decimals, ccm.CreatedAt, ccm.UpdatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for CollectionChainMapping.
func (q CollectionChainMappingQ) Upsert(ccm *data.CollectionChainMapping) error {
	return q.UpsertCtx(context.Background(), ccm)
}

// DeleteCtx deletes the CollectionChainMapping from the database.
func (q CollectionChainMappingQ) DeleteCtx(ctx context.Context, ccm *data.CollectionChainMapping) error {
	// delete with composite primary key
	sqlstr := `DELETE FROM public.collection_chain_mappings ` +
		`WHERE collection = $1 AND network = $2`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, ccm.Collection, ccm.Network); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the CollectionChainMapping from the database.
func (q CollectionChainMappingQ) Delete(ccm *data.CollectionChainMapping) error {
	return q.DeleteCtx(context.Background(), ccm)
} // ConfirmationQ represents helper struct to access row of 'confirmations'.
type ConfirmationQ struct {
	db *pgdb.DB
}

// NewConfirmationQ  - creates new instance
func NewConfirmationQ(db *pgdb.DB) ConfirmationQ {
	return ConfirmationQ{
		db,
	}
}

// ConfirmationQ  - creates new instance of ConfirmationQ
func (s Storage) ConfirmationQ() data.ConfirmationQ {
	return NewConfirmationQ(s.DB())
}

var colsConfirmation = `id, transfer_index, rarimo_transaction, created_at`

// InsertCtx inserts a Confirmation to the database.
func (q ConfirmationQ) InsertCtx(ctx context.Context, c *data.Confirmation) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.confirmations (` +
		`transfer_index, rarimo_transaction, created_at` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) RETURNING id`
		// run

	err := q.db.GetRawContext(ctx, &c.ID, sqlstr, c.TransferIndex, c.RarimoTransaction, c.CreatedAt)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// Insert insert a Confirmation to the database.
func (q ConfirmationQ) Insert(c *data.Confirmation) error {
	return q.InsertCtx(context.Background(), c)
}

// UpdateCtx updates a Confirmation in the database.
func (q ConfirmationQ) UpdateCtx(ctx context.Context, c *data.Confirmation) error {
	// update with composite primary key
	sqlstr := `UPDATE public.confirmations SET ` +
		`transfer_index = $1, rarimo_transaction = $2 ` +
		`WHERE id = $3`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, c.TransferIndex, c.RarimoTransaction, c.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Confirmation in the database.
func (q ConfirmationQ) Update(c *data.Confirmation) error {
	return q.UpdateCtx(context.Background(), c)
}

// UpsertCtx performs an upsert for Confirmation.
func (q ConfirmationQ) UpsertCtx(ctx context.Context, c *data.Confirmation) error {
	// upsert
	sqlstr := `INSERT INTO public.confirmations (` +
		`id, transfer_index, rarimo_transaction, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`transfer_index = EXCLUDED.transfer_index, rarimo_transaction = EXCLUDED.rarimo_transaction `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, c.ID, c.TransferIndex, c.RarimoTransaction, c.CreatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Confirmation.
func (q ConfirmationQ) Upsert(c *data.Confirmation) error {
	return q.UpsertCtx(context.Background(), c)
}

// DeleteCtx deletes the Confirmation from the database.
func (q ConfirmationQ) DeleteCtx(ctx context.Context, c *data.Confirmation) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.confirmations ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, c.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Confirmation from the database.
func (q ConfirmationQ) Delete(c *data.Confirmation) error {
	return q.DeleteCtx(context.Background(), c)
} // GorpMigrationQ represents helper struct to access row of 'gorp_migrations'.
type GorpMigrationQ struct {
	db *pgdb.DB
}

// NewGorpMigrationQ  - creates new instance
func NewGorpMigrationQ(db *pgdb.DB) GorpMigrationQ {
	return GorpMigrationQ{
		db,
	}
}

// GorpMigrationQ  - creates new instance of GorpMigrationQ
func (s Storage) GorpMigrationQ() data.GorpMigrationQ {
	return NewGorpMigrationQ(s.DB())
}

var colsGorpMigration = `id, applied_at`

// InsertCtx inserts a GorpMigration to the database.
func (q GorpMigrationQ) InsertCtx(ctx context.Context, gm *data.GorpMigration) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.gorp_migrations (` +
		`id, applied_at` +
		`) VALUES (` +
		`$1, $2` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, gm.ID, gm.AppliedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a GorpMigration to the database.
func (q GorpMigrationQ) Insert(gm *data.GorpMigration) error {
	return q.InsertCtx(context.Background(), gm)
}

// UpdateCtx updates a GorpMigration in the database.
func (q GorpMigrationQ) UpdateCtx(ctx context.Context, gm *data.GorpMigration) error {
	// update with composite primary key
	sqlstr := `UPDATE public.gorp_migrations SET ` +
		`applied_at = $1 ` +
		`WHERE id = $2`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, gm.AppliedAt, gm.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a GorpMigration in the database.
func (q GorpMigrationQ) Update(gm *data.GorpMigration) error {
	return q.UpdateCtx(context.Background(), gm)
}

// UpsertCtx performs an upsert for GorpMigration.
func (q GorpMigrationQ) UpsertCtx(ctx context.Context, gm *data.GorpMigration) error {
	// upsert
	sqlstr := `INSERT INTO public.gorp_migrations (` +
		`id, applied_at` +
		`) VALUES (` +
		`$1, $2` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`applied_at = EXCLUDED.applied_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, gm.ID, gm.AppliedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for GorpMigration.
func (q GorpMigrationQ) Upsert(gm *data.GorpMigration) error {
	return q.UpsertCtx(context.Background(), gm)
}

// DeleteCtx deletes the GorpMigration from the database.
func (q GorpMigrationQ) DeleteCtx(ctx context.Context, gm *data.GorpMigration) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.gorp_migrations ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, gm.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the GorpMigration from the database.
func (q GorpMigrationQ) Delete(gm *data.GorpMigration) error {
	return q.DeleteCtx(context.Background(), gm)
} // ItemQ represents helper struct to access row of 'items'.
type ItemQ struct {
	db *pgdb.DB
}

// NewItemQ  - creates new instance
func NewItemQ(db *pgdb.DB) ItemQ {
	return ItemQ{
		db,
	}
}

// ItemQ  - creates new instance of ItemQ
func (s Storage) ItemQ() data.ItemQ {
	return NewItemQ(s.DB())
}

var colsItem = `id, index, collection, metadata, created_at, updated_at`

// InsertCtx inserts a Item to the database.
func (q ItemQ) InsertCtx(ctx context.Context, i *data.Item) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.items (` +
		`index, collection, metadata, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) RETURNING id`
		// run

	err := q.db.GetRawContext(ctx, &i.ID, sqlstr, i.Index, i.Collection, i.Metadata, i.CreatedAt, i.UpdatedAt)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// Insert insert a Item to the database.
func (q ItemQ) Insert(i *data.Item) error {
	return q.InsertCtx(context.Background(), i)
}

// UpdateCtx updates a Item in the database.
func (q ItemQ) UpdateCtx(ctx context.Context, i *data.Item) error {
	// update with composite primary key
	sqlstr := `UPDATE public.items SET ` +
		`index = $1, collection = $2, metadata = $3, updated_at = $4 ` +
		`WHERE id = $5`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, i.Index, i.Collection, i.Metadata, i.UpdatedAt, i.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Item in the database.
func (q ItemQ) Update(i *data.Item) error {
	return q.UpdateCtx(context.Background(), i)
}

// UpsertCtx performs an upsert for Item.
func (q ItemQ) UpsertCtx(ctx context.Context, i *data.Item) error {
	// upsert
	sqlstr := `INSERT INTO public.items (` +
		`id, index, collection, metadata, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`index = EXCLUDED.index, collection = EXCLUDED.collection, metadata = EXCLUDED.metadata, updated_at = EXCLUDED.updated_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, i.ID, i.Index, i.Collection, i.Metadata, i.CreatedAt, i.UpdatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Item.
func (q ItemQ) Upsert(i *data.Item) error {
	return q.UpsertCtx(context.Background(), i)
}

// DeleteCtx deletes the Item from the database.
func (q ItemQ) DeleteCtx(ctx context.Context, i *data.Item) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.items ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, i.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Item from the database.
func (q ItemQ) Delete(i *data.Item) error {
	return q.DeleteCtx(context.Background(), i)
} // ItemChainMappingQ represents helper struct to access row of 'item_chain_mappings'.
type ItemChainMappingQ struct {
	db *pgdb.DB
}

// NewItemChainMappingQ  - creates new instance
func NewItemChainMappingQ(db *pgdb.DB) ItemChainMappingQ {
	return ItemChainMappingQ{
		db,
	}
}

// ItemChainMappingQ  - creates new instance of ItemChainMappingQ
func (s Storage) ItemChainMappingQ() data.ItemChainMappingQ {
	return NewItemChainMappingQ(s.DB())
}

var colsItemChainMapping = `item, network, address, token_id, created_at, updated_at`

// InsertCtx inserts a ItemChainMapping to the database.
func (q ItemChainMappingQ) InsertCtx(ctx context.Context, icm *data.ItemChainMapping) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.item_chain_mappings (` +
		`item, network, address, token_id, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, icm.Item, icm.Network, icm.Address, icm.TokenID, icm.CreatedAt, icm.UpdatedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a ItemChainMapping to the database.
func (q ItemChainMappingQ) Insert(icm *data.ItemChainMapping) error {
	return q.InsertCtx(context.Background(), icm)
}

// UpdateCtx updates a ItemChainMapping in the database.
func (q ItemChainMappingQ) UpdateCtx(ctx context.Context, icm *data.ItemChainMapping) error {
	// update with composite primary key
	sqlstr := `UPDATE public.item_chain_mappings SET ` +
		`address = $1, token_id = $2, updated_at = $3 ` +
		`WHERE item = $4 AND network = $5`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, icm.Address, icm.TokenID, icm.UpdatedAt, icm.Item, icm.Network)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a ItemChainMapping in the database.
func (q ItemChainMappingQ) Update(icm *data.ItemChainMapping) error {
	return q.UpdateCtx(context.Background(), icm)
}

// UpsertCtx performs an upsert for ItemChainMapping.
func (q ItemChainMappingQ) UpsertCtx(ctx context.Context, icm *data.ItemChainMapping) error {
	// upsert
	sqlstr := `INSERT INTO public.item_chain_mappings (` +
		`item, network, address, token_id, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)` +
		` ON CONFLICT (item, network) DO ` +
		`UPDATE SET ` +
		`address = EXCLUDED.address, token_id = EXCLUDED.token_id, updated_at = EXCLUDED.updated_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, icm.Item, icm.Network, icm.Address, icm.TokenID, icm.CreatedAt, icm.UpdatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for ItemChainMapping.
func (q ItemChainMappingQ) Upsert(icm *data.ItemChainMapping) error {
	return q.UpsertCtx(context.Background(), icm)
}

// DeleteCtx deletes the ItemChainMapping from the database.
func (q ItemChainMappingQ) DeleteCtx(ctx context.Context, icm *data.ItemChainMapping) error {
	// delete with composite primary key
	sqlstr := `DELETE FROM public.item_chain_mappings ` +
		`WHERE item = $1 AND network = $2`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, icm.Item, icm.Network); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the ItemChainMapping from the database.
func (q ItemChainMappingQ) Delete(icm *data.ItemChainMapping) error {
	return q.DeleteCtx(context.Background(), icm)
} // RejectionQ represents helper struct to access row of 'rejections'.
type RejectionQ struct {
	db *pgdb.DB
}

// NewRejectionQ  - creates new instance
func NewRejectionQ(db *pgdb.DB) RejectionQ {
	return RejectionQ{
		db,
	}
}

// RejectionQ  - creates new instance of RejectionQ
func (s Storage) RejectionQ() data.RejectionQ {
	return NewRejectionQ(s.DB())
}

var colsRejection = `id, transfer_index, rarimo_transaction, created_at`

// InsertCtx inserts a Rejection to the database.
func (q RejectionQ) InsertCtx(ctx context.Context, r *data.Rejection) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.rejections (` +
		`transfer_index, rarimo_transaction, created_at` +
		`) VALUES (` +
		`$1, $2, $3` +
		`) RETURNING id`
		// run

	err := q.db.GetRawContext(ctx, &r.ID, sqlstr, r.TransferIndex, r.RarimoTransaction, r.CreatedAt)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// Insert insert a Rejection to the database.
func (q RejectionQ) Insert(r *data.Rejection) error {
	return q.InsertCtx(context.Background(), r)
}

// UpdateCtx updates a Rejection in the database.
func (q RejectionQ) UpdateCtx(ctx context.Context, r *data.Rejection) error {
	// update with composite primary key
	sqlstr := `UPDATE public.rejections SET ` +
		`transfer_index = $1, rarimo_transaction = $2 ` +
		`WHERE id = $3`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, r.TransferIndex, r.RarimoTransaction, r.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Rejection in the database.
func (q RejectionQ) Update(r *data.Rejection) error {
	return q.UpdateCtx(context.Background(), r)
}

// UpsertCtx performs an upsert for Rejection.
func (q RejectionQ) UpsertCtx(ctx context.Context, r *data.Rejection) error {
	// upsert
	sqlstr := `INSERT INTO public.rejections (` +
		`id, transfer_index, rarimo_transaction, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`transfer_index = EXCLUDED.transfer_index, rarimo_transaction = EXCLUDED.rarimo_transaction `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, r.ID, r.TransferIndex, r.RarimoTransaction, r.CreatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Rejection.
func (q RejectionQ) Upsert(r *data.Rejection) error {
	return q.UpsertCtx(context.Background(), r)
}

// DeleteCtx deletes the Rejection from the database.
func (q RejectionQ) DeleteCtx(ctx context.Context, r *data.Rejection) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.rejections ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, r.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Rejection from the database.
func (q RejectionQ) Delete(r *data.Rejection) error {
	return q.DeleteCtx(context.Background(), r)
} // TransactionQ represents helper struct to access row of 'transactions'.
type TransactionQ struct {
	db *pgdb.DB
}

// NewTransactionQ  - creates new instance
func NewTransactionQ(db *pgdb.DB) TransactionQ {
	return TransactionQ{
		db,
	}
}

// TransactionQ  - creates new instance of TransactionQ
func (s Storage) TransactionQ() data.TransactionQ {
	return NewTransactionQ(s.DB())
}

var colsTransaction = `hash, block_height, index, raw_tx, tx_result, tx_timestamp, created_at`

// InsertCtx inserts a Transaction to the database.
func (q TransactionQ) InsertCtx(ctx context.Context, t *data.Transaction) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.transactions (` +
		`hash, block_height, index, raw_tx, tx_result, tx_timestamp, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, t.Hash, t.BlockHeight, t.Index, t.RawTx, t.TxResult, t.TxTimestamp, t.CreatedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a Transaction to the database.
func (q TransactionQ) Insert(t *data.Transaction) error {
	return q.InsertCtx(context.Background(), t)
}

// UpdateCtx updates a Transaction in the database.
func (q TransactionQ) UpdateCtx(ctx context.Context, t *data.Transaction) error {
	// update with composite primary key
	sqlstr := `UPDATE public.transactions SET ` +
		`block_height = $1, index = $2, raw_tx = $3, tx_result = $4, tx_timestamp = $5 ` +
		`WHERE hash = $6`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, t.BlockHeight, t.Index, t.RawTx, t.TxResult, t.TxTimestamp, t.Hash)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Transaction in the database.
func (q TransactionQ) Update(t *data.Transaction) error {
	return q.UpdateCtx(context.Background(), t)
}

// UpsertCtx performs an upsert for Transaction.
func (q TransactionQ) UpsertCtx(ctx context.Context, t *data.Transaction) error {
	// upsert
	sqlstr := `INSERT INTO public.transactions (` +
		`hash, block_height, index, raw_tx, tx_result, tx_timestamp, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)` +
		` ON CONFLICT (hash) DO ` +
		`UPDATE SET ` +
		`block_height = EXCLUDED.block_height, index = EXCLUDED.index, raw_tx = EXCLUDED.raw_tx, tx_result = EXCLUDED.tx_result, tx_timestamp = EXCLUDED.tx_timestamp `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, t.Hash, t.BlockHeight, t.Index, t.RawTx, t.TxResult, t.TxTimestamp, t.CreatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Transaction.
func (q TransactionQ) Upsert(t *data.Transaction) error {
	return q.UpsertCtx(context.Background(), t)
}

// DeleteCtx deletes the Transaction from the database.
func (q TransactionQ) DeleteCtx(ctx context.Context, t *data.Transaction) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.transactions ` +
		`WHERE hash = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, t.Hash); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Transaction from the database.
func (q TransactionQ) Delete(t *data.Transaction) error {
	return q.DeleteCtx(context.Background(), t)
} // TransferQ represents helper struct to access row of 'transfers'.
type TransferQ struct {
	db *pgdb.DB
}

// NewTransferQ  - creates new instance
func NewTransferQ(db *pgdb.DB) TransferQ {
	return TransferQ{
		db,
	}
}

// TransferQ  - creates new instance of TransferQ
func (s Storage) TransferQ() data.TransferQ {
	return NewTransferQ(s.DB())
}

var colsTransfer = `id, index, status, created_at, updated_at, creator, rarimo_tx, rarimo_tx_timestamp, origin, tx, event_id, from_chain, to_chain, receiver, amount, bundle_data, bundle_salt, token_index`

// InsertCtx inserts a Transfer to the database.
func (q TransferQ) InsertCtx(ctx context.Context, t *data.Transfer) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.transfers (` +
		`index, status, created_at, updated_at, creator, rarimo_tx, rarimo_tx_timestamp, origin, tx, event_id, from_chain, to_chain, receiver, amount, bundle_data, bundle_salt, token_index` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17` +
		`) RETURNING id`
		// run

	err := q.db.GetRawContext(ctx, &t.ID, sqlstr, t.Index, t.Status, t.CreatedAt, t.UpdatedAt, t.Creator, t.RarimoTx, t.RarimoTxTimestamp, t.Origin, t.Tx, t.EventID, t.FromChain, t.ToChain, t.Receiver, t.Amount, t.BundleData, t.BundleSalt, t.TokenIndex)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// Insert insert a Transfer to the database.
func (q TransferQ) Insert(t *data.Transfer) error {
	return q.InsertCtx(context.Background(), t)
}

// UpdateCtx updates a Transfer in the database.
func (q TransferQ) UpdateCtx(ctx context.Context, t *data.Transfer) error {
	// update with composite primary key
	sqlstr := `UPDATE public.transfers SET ` +
		`index = $1, status = $2, updated_at = $3, creator = $4, rarimo_tx = $5, rarimo_tx_timestamp = $6, origin = $7, tx = $8, event_id = $9, from_chain = $10, to_chain = $11, receiver = $12, amount = $13, bundle_data = $14, bundle_salt = $15, token_index = $16 ` +
		`WHERE id = $17`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, t.Index, t.Status, t.UpdatedAt, t.Creator, t.RarimoTx, t.RarimoTxTimestamp, t.Origin, t.Tx, t.EventID, t.FromChain, t.ToChain, t.Receiver, t.Amount, t.BundleData, t.BundleSalt, t.TokenIndex, t.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Transfer in the database.
func (q TransferQ) Update(t *data.Transfer) error {
	return q.UpdateCtx(context.Background(), t)
}

// UpsertCtx performs an upsert for Transfer.
func (q TransferQ) UpsertCtx(ctx context.Context, t *data.Transfer) error {
	// upsert
	sqlstr := `INSERT INTO public.transfers (` +
		`id, index, status, created_at, updated_at, creator, rarimo_tx, rarimo_tx_timestamp, origin, tx, event_id, from_chain, to_chain, receiver, amount, bundle_data, bundle_salt, token_index` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`index = EXCLUDED.index, status = EXCLUDED.status, updated_at = EXCLUDED.updated_at, creator = EXCLUDED.creator, rarimo_tx = EXCLUDED.rarimo_tx, rarimo_tx_timestamp = EXCLUDED.rarimo_tx_timestamp, origin = EXCLUDED.origin, tx = EXCLUDED.tx, event_id = EXCLUDED.event_id, from_chain = EXCLUDED.from_chain, to_chain = EXCLUDED.to_chain, receiver = EXCLUDED.receiver, amount = EXCLUDED.amount, bundle_data = EXCLUDED.bundle_data, bundle_salt = EXCLUDED.bundle_salt, token_index = EXCLUDED.token_index `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, t.ID, t.Index, t.Status, t.CreatedAt, t.UpdatedAt, t.Creator, t.RarimoTx, t.RarimoTxTimestamp, t.Origin, t.Tx, t.EventID, t.FromChain, t.ToChain, t.Receiver, t.Amount, t.BundleData, t.BundleSalt, t.TokenIndex); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Transfer.
func (q TransferQ) Upsert(t *data.Transfer) error {
	return q.UpsertCtx(context.Background(), t)
}

// DeleteCtx deletes the Transfer from the database.
func (q TransferQ) DeleteCtx(ctx context.Context, t *data.Transfer) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.transfers ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, t.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Transfer from the database.
func (q TransferQ) Delete(t *data.Transfer) error {
	return q.DeleteCtx(context.Background(), t)
} // VoteQ represents helper struct to access row of 'votes'.
type VoteQ struct {
	db *pgdb.DB
}

// NewVoteQ  - creates new instance
func NewVoteQ(db *pgdb.DB) VoteQ {
	return VoteQ{
		db,
	}
}

// VoteQ  - creates new instance of VoteQ
func (s Storage) VoteQ() data.VoteQ {
	return NewVoteQ(s.DB())
}

var colsVote = `id, transfer_index, choice, rarimo_transaction, created_at`

// InsertCtx inserts a Vote to the database.
func (q VoteQ) InsertCtx(ctx context.Context, v *data.Vote) error {
	// insert (primary key generated and returned by database)
	sqlstr := `INSERT INTO public.votes (` +
		`transfer_index, choice, rarimo_transaction, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4` +
		`) RETURNING id`
		// run

	err := q.db.GetRawContext(ctx, &v.ID, sqlstr, v.TransferIndex, v.Choice, v.RarimoTransaction, v.CreatedAt)
	if err != nil {
		return errors.Wrap(err, "failed to execute insert")
	}

	return nil
}

// Insert insert a Vote to the database.
func (q VoteQ) Insert(v *data.Vote) error {
	return q.InsertCtx(context.Background(), v)
}

// UpdateCtx updates a Vote in the database.
func (q VoteQ) UpdateCtx(ctx context.Context, v *data.Vote) error {
	// update with composite primary key
	sqlstr := `UPDATE public.votes SET ` +
		`transfer_index = $1, choice = $2, rarimo_transaction = $3 ` +
		`WHERE id = $4`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, v.TransferIndex, v.Choice, v.RarimoTransaction, v.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Vote in the database.
func (q VoteQ) Update(v *data.Vote) error {
	return q.UpdateCtx(context.Background(), v)
}

// UpsertCtx performs an upsert for Vote.
func (q VoteQ) UpsertCtx(ctx context.Context, v *data.Vote) error {
	// upsert
	sqlstr := `INSERT INTO public.votes (` +
		`id, transfer_index, choice, rarimo_transaction, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`transfer_index = EXCLUDED.transfer_index, choice = EXCLUDED.choice, rarimo_transaction = EXCLUDED.rarimo_transaction `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, v.ID, v.TransferIndex, v.Choice, v.RarimoTransaction, v.CreatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Vote.
func (q VoteQ) Upsert(v *data.Vote) error {
	return q.UpsertCtx(context.Background(), v)
}

// DeleteCtx deletes the Vote from the database.
func (q VoteQ) DeleteCtx(ctx context.Context, v *data.Vote) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.votes ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, v.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Vote from the database.
func (q VoteQ) Delete(v *data.Vote) error {
	return q.DeleteCtx(context.Background(), v)
}

// ApprovalByIDCtx retrieves a row from 'public.approvals' as a Approval.
//
// Generated from index 'approvals_pkey'.
func (q ApprovalQ) ApprovalByIDCtx(ctx context.Context, id int64, isForUpdate bool) (*data.Approval, error) {
	// query
	sqlstr := `SELECT ` +
		`id, transfer_index, rarimo_transaction, created_at ` +
		`FROM public.approvals ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Approval
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// ApprovalByID retrieves a row from 'public.approvals' as a Approval.
//
// Generated from index 'approvals_pkey'.
func (q ApprovalQ) ApprovalByID(id int64, isForUpdate bool) (*data.Approval, error) {
	return q.ApprovalByIDCtx(context.Background(), id, isForUpdate)
}

// ApprovalsByTransferIndexCtx retrieves a row from 'public.approvals' as a Approval.
//
// Generated from index 'approvals_transfer_index'.
func (q ApprovalQ) ApprovalsByTransferIndexCtx(ctx context.Context, transferIndex []byte, isForUpdate bool) ([]data.Approval, error) {
	// query
	sqlstr := `SELECT ` +
		`id, transfer_index, rarimo_transaction, created_at ` +
		`FROM public.approvals ` +
		`WHERE transfer_index = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.Approval
	err := q.db.SelectRawContext(ctx, &res, sqlstr, transferIndex)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// ApprovalsByTransferIndex retrieves a row from 'public.approvals' as a Approval.
//
// Generated from index 'approvals_transfer_index'.
func (q ApprovalQ) ApprovalsByTransferIndex(transferIndex []byte, isForUpdate bool) ([]data.Approval, error) {
	return q.ApprovalsByTransferIndexCtx(context.Background(), transferIndex, isForUpdate)
}

// CollectionByIndexCtx retrieves a row from 'public.collections' as a Collection.
//
// Generated from index 'collections_index_key'.
func (q CollectionQ) CollectionByIndexCtx(ctx context.Context, index []byte, isForUpdate bool) (*data.Collection, error) {
	// query
	sqlstr := `SELECT ` +
		`id, index, metadata, created_at, updated_at ` +
		`FROM public.collections ` +
		`WHERE index = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Collection
	err := q.db.GetRawContext(ctx, &res, sqlstr, index)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// CollectionByIndex retrieves a row from 'public.collections' as a Collection.
//
// Generated from index 'collections_index_key'.
func (q CollectionQ) CollectionByIndex(index []byte, isForUpdate bool) (*data.Collection, error) {
	return q.CollectionByIndexCtx(context.Background(), index, isForUpdate)
}

// CollectionByIDCtx retrieves a row from 'public.collections' as a Collection.
//
// Generated from index 'collections_pkey'.
func (q CollectionQ) CollectionByIDCtx(ctx context.Context, id int64, isForUpdate bool) (*data.Collection, error) {
	// query
	sqlstr := `SELECT ` +
		`id, index, metadata, created_at, updated_at ` +
		`FROM public.collections ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Collection
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// CollectionByID retrieves a row from 'public.collections' as a Collection.
//
// Generated from index 'collections_pkey'.
func (q CollectionQ) CollectionByID(id int64, isForUpdate bool) (*data.Collection, error) {
	return q.CollectionByIDCtx(context.Background(), id, isForUpdate)
}

// CollectionChainMappingsByCollectionCtx retrieves a row from 'public.collection_chain_mappings' as a CollectionChainMapping.
//
// Generated from index 'collection_chain_mappings_collection'.
func (q CollectionChainMappingQ) CollectionChainMappingsByCollectionCtx(ctx context.Context, collection int64, isForUpdate bool) ([]data.CollectionChainMapping, error) {
	// query
	sqlstr := `SELECT ` +
		`collection, network, address, token_type, wrapped, decimals, created_at, updated_at ` +
		`FROM public.collection_chain_mappings ` +
		`WHERE collection = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.CollectionChainMapping
	err := q.db.SelectRawContext(ctx, &res, sqlstr, collection)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// CollectionChainMappingsByCollection retrieves a row from 'public.collection_chain_mappings' as a CollectionChainMapping.
//
// Generated from index 'collection_chain_mappings_collection'.
func (q CollectionChainMappingQ) CollectionChainMappingsByCollection(collection int64, isForUpdate bool) ([]data.CollectionChainMapping, error) {
	return q.CollectionChainMappingsByCollectionCtx(context.Background(), collection, isForUpdate)
}

// CollectionChainMappingsByNetworkCtx retrieves a row from 'public.collection_chain_mappings' as a CollectionChainMapping.
//
// Generated from index 'collection_chain_mappings_network'.
func (q CollectionChainMappingQ) CollectionChainMappingsByNetworkCtx(ctx context.Context, network int, isForUpdate bool) ([]data.CollectionChainMapping, error) {
	// query
	sqlstr := `SELECT ` +
		`collection, network, address, token_type, wrapped, decimals, created_at, updated_at ` +
		`FROM public.collection_chain_mappings ` +
		`WHERE network = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.CollectionChainMapping
	err := q.db.SelectRawContext(ctx, &res, sqlstr, network)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// CollectionChainMappingsByNetwork retrieves a row from 'public.collection_chain_mappings' as a CollectionChainMapping.
//
// Generated from index 'collection_chain_mappings_network'.
func (q CollectionChainMappingQ) CollectionChainMappingsByNetwork(network int, isForUpdate bool) ([]data.CollectionChainMapping, error) {
	return q.CollectionChainMappingsByNetworkCtx(context.Background(), network, isForUpdate)
}

// CollectionChainMappingByCollectionNetworkCtx retrieves a row from 'public.collection_chain_mappings' as a CollectionChainMapping.
//
// Generated from index 'collection_chain_mappings_pkey'.
func (q CollectionChainMappingQ) CollectionChainMappingByCollectionNetworkCtx(ctx context.Context, collection int64, network int, isForUpdate bool) (*data.CollectionChainMapping, error) {
	// query
	sqlstr := `SELECT ` +
		`collection, network, address, token_type, wrapped, decimals, created_at, updated_at ` +
		`FROM public.collection_chain_mappings ` +
		`WHERE collection = $1 AND network = $2`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.CollectionChainMapping
	err := q.db.GetRawContext(ctx, &res, sqlstr, collection, network)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// CollectionChainMappingByCollectionNetwork retrieves a row from 'public.collection_chain_mappings' as a CollectionChainMapping.
//
// Generated from index 'collection_chain_mappings_pkey'.
func (q CollectionChainMappingQ) CollectionChainMappingByCollectionNetwork(collection int64, network int, isForUpdate bool) (*data.CollectionChainMapping, error) {
	return q.CollectionChainMappingByCollectionNetworkCtx(context.Background(), collection, network, isForUpdate)
}

// ConfirmationByIDCtx retrieves a row from 'public.confirmations' as a Confirmation.
//
// Generated from index 'confirmations_pkey'.
func (q ConfirmationQ) ConfirmationByIDCtx(ctx context.Context, id int64, isForUpdate bool) (*data.Confirmation, error) {
	// query
	sqlstr := `SELECT ` +
		`id, transfer_index, rarimo_transaction, created_at ` +
		`FROM public.confirmations ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Confirmation
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// ConfirmationByID retrieves a row from 'public.confirmations' as a Confirmation.
//
// Generated from index 'confirmations_pkey'.
func (q ConfirmationQ) ConfirmationByID(id int64, isForUpdate bool) (*data.Confirmation, error) {
	return q.ConfirmationByIDCtx(context.Background(), id, isForUpdate)
}

// ConfirmationsByTransferIndexCtx retrieves a row from 'public.confirmations' as a Confirmation.
//
// Generated from index 'confirmations_transfer_index'.
func (q ConfirmationQ) ConfirmationsByTransferIndexCtx(ctx context.Context, transferIndex []byte, isForUpdate bool) ([]data.Confirmation, error) {
	// query
	sqlstr := `SELECT ` +
		`id, transfer_index, rarimo_transaction, created_at ` +
		`FROM public.confirmations ` +
		`WHERE transfer_index = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.Confirmation
	err := q.db.SelectRawContext(ctx, &res, sqlstr, transferIndex)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// ConfirmationsByTransferIndex retrieves a row from 'public.confirmations' as a Confirmation.
//
// Generated from index 'confirmations_transfer_index'.
func (q ConfirmationQ) ConfirmationsByTransferIndex(transferIndex []byte, isForUpdate bool) ([]data.Confirmation, error) {
	return q.ConfirmationsByTransferIndexCtx(context.Background(), transferIndex, isForUpdate)
}

// ConfirmationByTransferIndexCtx retrieves a row from 'public.confirmations' as a Confirmation.
//
// Generated from index 'confirmations_transfer_index_key'.
func (q ConfirmationQ) ConfirmationByTransferIndexCtx(ctx context.Context, transferIndex []byte, isForUpdate bool) (*data.Confirmation, error) {
	// query
	sqlstr := `SELECT ` +
		`id, transfer_index, rarimo_transaction, created_at ` +
		`FROM public.confirmations ` +
		`WHERE transfer_index = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Confirmation
	err := q.db.GetRawContext(ctx, &res, sqlstr, transferIndex)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// ConfirmationByTransferIndex retrieves a row from 'public.confirmations' as a Confirmation.
//
// Generated from index 'confirmations_transfer_index_key'.
func (q ConfirmationQ) ConfirmationByTransferIndex(transferIndex []byte, isForUpdate bool) (*data.Confirmation, error) {
	return q.ConfirmationByTransferIndexCtx(context.Background(), transferIndex, isForUpdate)
}

// GorpMigrationByIDCtx retrieves a row from 'public.gorp_migrations' as a GorpMigration.
//
// Generated from index 'gorp_migrations_pkey'.
func (q GorpMigrationQ) GorpMigrationByIDCtx(ctx context.Context, id string, isForUpdate bool) (*data.GorpMigration, error) {
	// query
	sqlstr := `SELECT ` +
		`id, applied_at ` +
		`FROM public.gorp_migrations ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.GorpMigration
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// GorpMigrationByID retrieves a row from 'public.gorp_migrations' as a GorpMigration.
//
// Generated from index 'gorp_migrations_pkey'.
func (q GorpMigrationQ) GorpMigrationByID(id string, isForUpdate bool) (*data.GorpMigration, error) {
	return q.GorpMigrationByIDCtx(context.Background(), id, isForUpdate)
}

// ItemsByCollectionCtx retrieves a row from 'public.items' as a Item.
//
// Generated from index 'item_collection'.
func (q ItemQ) ItemsByCollectionCtx(ctx context.Context, collection sql.NullInt64, isForUpdate bool) ([]data.Item, error) {
	// query
	sqlstr := `SELECT ` +
		`id, index, collection, metadata, created_at, updated_at ` +
		`FROM public.items ` +
		`WHERE collection = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.Item
	err := q.db.SelectRawContext(ctx, &res, sqlstr, collection)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// ItemsByCollection retrieves a row from 'public.items' as a Item.
//
// Generated from index 'item_collection'.
func (q ItemQ) ItemsByCollection(collection sql.NullInt64, isForUpdate bool) ([]data.Item, error) {
	return q.ItemsByCollectionCtx(context.Background(), collection, isForUpdate)
}

// ItemByIndexCtx retrieves a row from 'public.items' as a Item.
//
// Generated from index 'items_index_key'.
func (q ItemQ) ItemByIndexCtx(ctx context.Context, index []byte, isForUpdate bool) (*data.Item, error) {
	// query
	sqlstr := `SELECT ` +
		`id, index, collection, metadata, created_at, updated_at ` +
		`FROM public.items ` +
		`WHERE index = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Item
	err := q.db.GetRawContext(ctx, &res, sqlstr, index)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// ItemByIndex retrieves a row from 'public.items' as a Item.
//
// Generated from index 'items_index_key'.
func (q ItemQ) ItemByIndex(index []byte, isForUpdate bool) (*data.Item, error) {
	return q.ItemByIndexCtx(context.Background(), index, isForUpdate)
}

// ItemByIDCtx retrieves a row from 'public.items' as a Item.
//
// Generated from index 'items_pkey'.
func (q ItemQ) ItemByIDCtx(ctx context.Context, id int64, isForUpdate bool) (*data.Item, error) {
	// query
	sqlstr := `SELECT ` +
		`id, index, collection, metadata, created_at, updated_at ` +
		`FROM public.items ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Item
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// ItemByID retrieves a row from 'public.items' as a Item.
//
// Generated from index 'items_pkey'.
func (q ItemQ) ItemByID(id int64, isForUpdate bool) (*data.Item, error) {
	return q.ItemByIDCtx(context.Background(), id, isForUpdate)
}

// ItemChainMappingsByAddressCtx retrieves a row from 'public.item_chain_mappings' as a ItemChainMapping.
//
// Generated from index 'item_chain_mapping_address'.
func (q ItemChainMappingQ) ItemChainMappingsByAddressCtx(ctx context.Context, address []byte, isForUpdate bool) ([]data.ItemChainMapping, error) {
	// query
	sqlstr := `SELECT ` +
		`item, network, address, token_id, created_at, updated_at ` +
		`FROM public.item_chain_mappings ` +
		`WHERE address = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.ItemChainMapping
	err := q.db.SelectRawContext(ctx, &res, sqlstr, address)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// ItemChainMappingsByAddress retrieves a row from 'public.item_chain_mappings' as a ItemChainMapping.
//
// Generated from index 'item_chain_mapping_address'.
func (q ItemChainMappingQ) ItemChainMappingsByAddress(address []byte, isForUpdate bool) ([]data.ItemChainMapping, error) {
	return q.ItemChainMappingsByAddressCtx(context.Background(), address, isForUpdate)
}

// ItemChainMappingsByItemCtx retrieves a row from 'public.item_chain_mappings' as a ItemChainMapping.
//
// Generated from index 'item_chain_mapping_item'.
func (q ItemChainMappingQ) ItemChainMappingsByItemCtx(ctx context.Context, item int64, isForUpdate bool) ([]data.ItemChainMapping, error) {
	// query
	sqlstr := `SELECT ` +
		`item, network, address, token_id, created_at, updated_at ` +
		`FROM public.item_chain_mappings ` +
		`WHERE item = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.ItemChainMapping
	err := q.db.SelectRawContext(ctx, &res, sqlstr, item)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// ItemChainMappingsByItem retrieves a row from 'public.item_chain_mappings' as a ItemChainMapping.
//
// Generated from index 'item_chain_mapping_item'.
func (q ItemChainMappingQ) ItemChainMappingsByItem(item int64, isForUpdate bool) ([]data.ItemChainMapping, error) {
	return q.ItemChainMappingsByItemCtx(context.Background(), item, isForUpdate)
}

// ItemChainMappingsByNetworkCtx retrieves a row from 'public.item_chain_mappings' as a ItemChainMapping.
//
// Generated from index 'item_chain_mapping_network'.
func (q ItemChainMappingQ) ItemChainMappingsByNetworkCtx(ctx context.Context, network int, isForUpdate bool) ([]data.ItemChainMapping, error) {
	// query
	sqlstr := `SELECT ` +
		`item, network, address, token_id, created_at, updated_at ` +
		`FROM public.item_chain_mappings ` +
		`WHERE network = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.ItemChainMapping
	err := q.db.SelectRawContext(ctx, &res, sqlstr, network)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// ItemChainMappingsByNetwork retrieves a row from 'public.item_chain_mappings' as a ItemChainMapping.
//
// Generated from index 'item_chain_mapping_network'.
func (q ItemChainMappingQ) ItemChainMappingsByNetwork(network int, isForUpdate bool) ([]data.ItemChainMapping, error) {
	return q.ItemChainMappingsByNetworkCtx(context.Background(), network, isForUpdate)
}

// ItemChainMappingByItemNetworkCtx retrieves a row from 'public.item_chain_mappings' as a ItemChainMapping.
//
// Generated from index 'item_chain_mappings_pkey'.
func (q ItemChainMappingQ) ItemChainMappingByItemNetworkCtx(ctx context.Context, item int64, network int, isForUpdate bool) (*data.ItemChainMapping, error) {
	// query
	sqlstr := `SELECT ` +
		`item, network, address, token_id, created_at, updated_at ` +
		`FROM public.item_chain_mappings ` +
		`WHERE item = $1 AND network = $2`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.ItemChainMapping
	err := q.db.GetRawContext(ctx, &res, sqlstr, item, network)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// ItemChainMappingByItemNetwork retrieves a row from 'public.item_chain_mappings' as a ItemChainMapping.
//
// Generated from index 'item_chain_mappings_pkey'.
func (q ItemChainMappingQ) ItemChainMappingByItemNetwork(item int64, network int, isForUpdate bool) (*data.ItemChainMapping, error) {
	return q.ItemChainMappingByItemNetworkCtx(context.Background(), item, network, isForUpdate)
}

// RejectionByIDCtx retrieves a row from 'public.rejections' as a Rejection.
//
// Generated from index 'rejections_pkey'.
func (q RejectionQ) RejectionByIDCtx(ctx context.Context, id int64, isForUpdate bool) (*data.Rejection, error) {
	// query
	sqlstr := `SELECT ` +
		`id, transfer_index, rarimo_transaction, created_at ` +
		`FROM public.rejections ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Rejection
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// RejectionByID retrieves a row from 'public.rejections' as a Rejection.
//
// Generated from index 'rejections_pkey'.
func (q RejectionQ) RejectionByID(id int64, isForUpdate bool) (*data.Rejection, error) {
	return q.RejectionByIDCtx(context.Background(), id, isForUpdate)
}

// RejectionsByTransferIndexCtx retrieves a row from 'public.rejections' as a Rejection.
//
// Generated from index 'rejections_transfer_index'.
func (q RejectionQ) RejectionsByTransferIndexCtx(ctx context.Context, transferIndex []byte, isForUpdate bool) ([]data.Rejection, error) {
	// query
	sqlstr := `SELECT ` +
		`id, transfer_index, rarimo_transaction, created_at ` +
		`FROM public.rejections ` +
		`WHERE transfer_index = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.Rejection
	err := q.db.SelectRawContext(ctx, &res, sqlstr, transferIndex)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// RejectionsByTransferIndex retrieves a row from 'public.rejections' as a Rejection.
//
// Generated from index 'rejections_transfer_index'.
func (q RejectionQ) RejectionsByTransferIndex(transferIndex []byte, isForUpdate bool) ([]data.Rejection, error) {
	return q.RejectionsByTransferIndexCtx(context.Background(), transferIndex, isForUpdate)
}

// TransactionByHashCtx retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_pkey'.
func (q TransactionQ) TransactionByHashCtx(ctx context.Context, hash []byte, isForUpdate bool) (*data.Transaction, error) {
	// query
	sqlstr := `SELECT ` +
		`hash, block_height, index, raw_tx, tx_result, tx_timestamp, created_at ` +
		`FROM public.transactions ` +
		`WHERE hash = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Transaction
	err := q.db.GetRawContext(ctx, &res, sqlstr, hash)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// TransactionByHash retrieves a row from 'public.transactions' as a Transaction.
//
// Generated from index 'transactions_pkey'.
func (q TransactionQ) TransactionByHash(hash []byte, isForUpdate bool) (*data.Transaction, error) {
	return q.TransactionByHashCtx(context.Background(), hash, isForUpdate)
}

// TransferByIndexCtx retrieves a row from 'public.transfers' as a Transfer.
//
// Generated from index 'transfers_index_key'.
func (q TransferQ) TransferByIndexCtx(ctx context.Context, index []byte, isForUpdate bool) (*data.Transfer, error) {
	// query
	sqlstr := `SELECT ` +
		`id, index, status, created_at, updated_at, creator, rarimo_tx, rarimo_tx_timestamp, origin, tx, event_id, from_chain, to_chain, receiver, amount, bundle_data, bundle_salt, token_index ` +
		`FROM public.transfers ` +
		`WHERE index = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Transfer
	err := q.db.GetRawContext(ctx, &res, sqlstr, index)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// TransferByIndex retrieves a row from 'public.transfers' as a Transfer.
//
// Generated from index 'transfers_index_key'.
func (q TransferQ) TransferByIndex(index []byte, isForUpdate bool) (*data.Transfer, error) {
	return q.TransferByIndexCtx(context.Background(), index, isForUpdate)
}

// TransferByIDCtx retrieves a row from 'public.transfers' as a Transfer.
//
// Generated from index 'transfers_pkey'.
func (q TransferQ) TransferByIDCtx(ctx context.Context, id int64, isForUpdate bool) (*data.Transfer, error) {
	// query
	sqlstr := `SELECT ` +
		`id, index, status, created_at, updated_at, creator, rarimo_tx, rarimo_tx_timestamp, origin, tx, event_id, from_chain, to_chain, receiver, amount, bundle_data, bundle_salt, token_index ` +
		`FROM public.transfers ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Transfer
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// TransferByID retrieves a row from 'public.transfers' as a Transfer.
//
// Generated from index 'transfers_pkey'.
func (q TransferQ) TransferByID(id int64, isForUpdate bool) (*data.Transfer, error) {
	return q.TransferByIDCtx(context.Background(), id, isForUpdate)
}

// VoteByIDCtx retrieves a row from 'public.votes' as a Vote.
//
// Generated from index 'votes_pkey'.
func (q VoteQ) VoteByIDCtx(ctx context.Context, id int64, isForUpdate bool) (*data.Vote, error) {
	// query
	sqlstr := `SELECT ` +
		`id, transfer_index, choice, rarimo_transaction, created_at ` +
		`FROM public.votes ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Vote
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// VoteByID retrieves a row from 'public.votes' as a Vote.
//
// Generated from index 'votes_pkey'.
func (q VoteQ) VoteByID(id int64, isForUpdate bool) (*data.Vote, error) {
	return q.VoteByIDCtx(context.Background(), id, isForUpdate)
}

// VotesByTransferIndexCtx retrieves a row from 'public.votes' as a Vote.
//
// Generated from index 'votes_transfer_index'.
func (q VoteQ) VotesByTransferIndexCtx(ctx context.Context, transferIndex []byte, isForUpdate bool) ([]data.Vote, error) {
	// query
	sqlstr := `SELECT ` +
		`id, transfer_index, choice, rarimo_transaction, created_at ` +
		`FROM public.votes ` +
		`WHERE transfer_index = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.Vote
	err := q.db.SelectRawContext(ctx, &res, sqlstr, transferIndex)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// VotesByTransferIndex retrieves a row from 'public.votes' as a Vote.
//
// Generated from index 'votes_transfer_index'.
func (q VoteQ) VotesByTransferIndex(transferIndex []byte, isForUpdate bool) ([]data.Vote, error) {
	return q.VotesByTransferIndexCtx(context.Background(), transferIndex, isForUpdate)
}
